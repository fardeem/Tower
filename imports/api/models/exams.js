import { Meteor } from 'meteor/meteor';
import { check } from 'meteor/check';
import { Mongo } from 'meteor/mongo';
import { SimpleSchema } from 'meteor/aldeed:simple-schema';
import { ValidatedMethod } from 'meteor/mdg:validated-method';

import { Random } from 'meteor/random';
import { groupBy } from 'lodash';

import { Subjects } from './subjects.js';
import { Sessions } from './sessions.js';


export const Exams = new Mongo.Collection('exams');

const schema = new SimpleSchema({
  name: { type: String },
  date: { type: Date },
  time: { type: String, regEx: /^(\d){2}:(\d){2}$/ },
  subjects: { type: [String], regEx: SimpleSchema.RegEx.Id },
  grades: { type: [Number] },
  days: { type: Number },
});

Exams.attachSchema(schema);


/* Utils */


/**
 * Exam factory to calculate various exam things :P
 *
 * @param  {[Subjects]}.
 * @returns {Object} exam - The exam info generated by the factory
 * @returns {String} exam.examId - Mongo _id
 * @returns {Array}  exam.grades - The grades in this series.
 * @returns {Number} exam.days - Total number of days to finish all the exams
 * @returns {[Sessions]} exam.sessions
 */
const ExamFactory = (subjects = []) => {
  const _grouped = groupBy(subjects, 'grade');

  const examId = Random.id();
  const grades = Object.keys(_grouped);


  /**
   * Calculates the number of days needed to
   * complete all the exams.
   *
   * The function starts with day = 0; It then
   * iterates over all the subjects in each grade,
   * and reassigns day with the largest of it's
   * value and the length of the subjects array.
   *
   * @return {Number}
   */
  const days = (() => {
    let _days = 0;
    grades.forEach((grade) => {
      _days = Math.max(_days, _grouped[grade].length);
    });

    return _days;
  })();


  /**
   * Calculates the sessions for a particular day.
   *
   * Starts with an empty sessions array. It then
   * selects the subject for each grade at the
   * particular index(defined by day) and pushes
   * the subject id into the sessions array;
   *
   * @param  {Number} day
   * @return {Array}  An array of subject ids.
   */
  const getSessionsForDay = (day = 0) => {
    const sessions = [];

    grades.forEach((grade) => {
      const current = _grouped[grade][day];

      if (current === undefined) return;
      sessions.push(current._id);
    });

    return sessions;
  };


  /**
   * Calculates all the sessions for the exam.
   *
   * Starts with an empty sessions array. Loops
   * through each day, with each time reassigning
   * sessions with its previous value and the sessions
   * for that day.
   *
   * @return {Session}
   */
  const getSessions = () => {
    let sessions = [];
    let day = 0;
    const mapIdToDocument = (subjectId) => ({
      _id: Random.id(), examId, subjectId, day, room: [] });

    for (; day <= days; day++) {
      sessions =
        getSessionsForDay(day)
        .map(mapIdToDocument)
        .concat(sessions);
    }

    return sessions;
  };


  return {
    examId,
    grades,
    days,
    sessions: getSessions(),
  };
};


/* Methods */

export const add = new ValidatedMethod({
  name: 'exams.add',
  validate: schema.pick([
    'name', 'date', 'time', 'subjects', 'subjects.$',
  ]).validator(),
  run({ name, date, time, subjects }) {
    const { examId, grades, days, sessions } = new ExamFactory(
      Subjects.find({ _id: { $in: subjects } }).fetch()
    );

    return Exams.insert({
      _id: examId, name, date, time, subjects, grades, days,
    }, (err, res) => {
      if (! this.isSimulation) {
        return Sessions.rawCollection().insert(sessions, () => res);
      }

      return res;
    });
  },
});

